# Урок 1.6: Жизненный цикл акторов
Вах! Вы только посмотрите на себя! Сумели добраться до конца первого блока! Поздравляем. Серьезно. Мы очень ценим и благодарим вас за вашу настойчивость в учебе.

Данный урок будет завершающим в нашей серии "основы работы с акторами". И завершим мы одной из самых важных концепций - жизненным циклом акторов.

## Ключевые концепции / общая информация
### Что такое жизненный цикл актора?
У акторов есть жестко заданный жизненный цикл. Сначала актора создают, потом запускают, но основное время жизни он проводит за получением и обработкой сообщений. В случае, если актор вам больше не нужен, вы можете его остановить.

### Из каких этапов состоит жизненный цикл актора?
В Akka.NET существует 5 основных этапов жизненного цикла актора:

1. `Starting` (Актор в процессе запуска)
2. `Receiving` (Актор обрабатывает сообщения)
3. `Stopping` (Актор в процессе остановки)
4. `Terminated`, (Актор остановлен)
5. `Restarting` (Актор в процессе перезапуска)

![жизненный цикл актора в Akka.NET](Images/lifecycle.png)

Давайте разберем их по порядку.

#### `Starting` (Актор в процессе запуска)
Актор просыпается. Это первоначальное состояние актора, когда он инициализируется при помощи `ActorSystem`.

#### `Receiving` (Актор получает сообщения)
Актор готов принимать сообщения. Его почтовый ящик (`Mailbox` об этом чуть позже), начинает передавать сообщения для обработки в метод `OnReceive`.

#### `Stopping` (Актор в процессе остановки)
На протяжении этойго этапа актор очищает свое состояние. Что именно происходит - зависит от того, останавливается ли актор или же просто перезапускается.


Если актор перезапускается, он обычно сохраняет свое состояние и/или сообщения, чтобы обработать их после перезапуска.


Если актор останавливается, все сообщения из его почтового ящика (`Mailbox` ) пересылаются в специальное хранилище недоставленных сообщений ( `DeadLetters`) у `ActorSystem`. В `DeadLetters` сообщения, которые невозомжно доставить, например потому что актор-получатель уже не существует.

#### `Terminated` (Актор остановлен)
Актер мертв.  Любые сообщения, посылаемые его `IActorRef`, попадут в `DeadLetters`. Такого актора нельзя перезапустить. Однако можно создать нового актора с тем же адресом. У него будет другая  `IActorRef` , но тот же самый путь (`ActorPath`).

#### `Restarting` (Актор в состоянии перезапуска)
Актор будет перезапущен и скоро перейдет в состояние `Starting`

### Жизенный цикл и методы обработчики
Итак, как вы можете вклиниться в жизенный цикл аткоров ? Существует 4 места на которые вы можете подписаться.

#### `PreStart` (Предзапуск)
Код в методе `PreStart`  выполняется до того, как актор начнет получать сообщения. И это неплохое место для проведения инициализации. Этот метод также вызывается при перезапуске.

#### `PreRestart` (ПредПереЗапуск)
Если ваш актор случайно упал (т.е. бросил необработанное исключение), родитель перезапустит его. Внутри `PreRestart` можно почистить ресурсы перед перезапуском или сохранить текущее сообщения для последующей обработки.

#### `PostStop` (ПостОстановка)
`PostStop` вызыается в момент, когда актор уже остановлен и не получает сообщений.  В этом методе можно делать очистку ресурсов.  Этот метод также вызывается во время `PreRestart`. Но вы можете переопределить  `PreRestart`, и не вызывать `base.PreRestart` , если вас не устраивает такое поведение. 

`DeathWatch` также вызывается из метода `PostStop`. `DeathWatch` - система подписки, которая позволяет любому актору получить уведомление о завершении работы любого другого актора. 

#### `PostRestart` (Пост-перезапуск)
`PostRestart` вызывается после PreRestart, но перед PreStart. Здесь хорошо  добавлять логику и дополнительную диагностику о возможных причинах сбоя.

Вот как методы обработчики ложатся на жизненный цикл актора:

![Жизенный цикл актора Akka.NET с указанием методов](Images/lifecycle_methods.png)

### Как мне все-таки вклиниться в жизеннный цикл актора?
Для этого просто перегрузите необходимый метод, например вот так:

```csharp
 /// <summary>
/// Инициализация аткора
/// </summary>
protected override void PreStart()
{
    // здесь можно делать что угодно
}
```

### Какие методы жизенного цикла используются больше всего ??
#### `PreStart`
`PreStart` Самый популярный (с большим отрывом от конкурентов).  Он используется для установки первоначального состояния актора, и выполнения любых действий в процессе инициализации..

#### `PostStop`
Второй наиболее используемый метод - `PostStop`,  позволяет производить очистку ресурсов. Например, закрывать файловые (или другие неуправляемые)ресурсы преед своим завершением.

#### `PreRestart`
`PreRestart` на почетном третьем месте. Он используется доволно редко, но бывает очень полезен. Например можно сохранить сообщение в специальный стек, или сохранить состояние актора каким-то другим образом. Тогда после перезапуска актор сможет восстановить свое состояне.

### Какое отношение жизненный цикл и методы имеют к супервизорам?
В том случае, если актор упадет (выбросит необработанное исключение), супервизор этого актора автоматически перезапустит его. И жизенный цикл актора начнется с самого начала. Без потери сообщений, которые находятся в его почтовом ящике.

На четвертом уроке мы выяснили, что поведение в случае необработанных исключений зависит от директивы супервизора (`SupervisionDirective`). Супервизор может сказать дочернему актору перезапуститься, остановиться или проигнорировать ошибку и продолжить выполнение. По умолчанию актор будет перезапущен, с очисткой всех данных, которые возомжно привели к исключению. Перезапуск выоплняется очень быстро, поэтому можно сильно не беспокоиться о производительности.

## Упражнение
Это упражнение будет очень коротким, поскольку наша система уже полностью готова. Нам предстоит улучшить процессы инициализации и остановки актора `TailActor`.

### Переносим инициализацию из конструктора `TailActor` в `PreStart()`
Видите, сколько всего происходит в конструкции `TailActor`?

```csharp
// Начинаем следить за именением файла
_observer = new FileObserver(Self, Path.GetFullPath(_filePath));
_observer.Start();

// Открываем файловый поток с правами на разделенные чтение\запись (таким образом можно одновременно записывать и читать из файла)

_fileStream = new FileStream(Path.GetFullPath(_filePath), FileMode.Open, FileAccess.Read,
    FileShare.ReadWrite);
_fileStreamReader = new StreamReader(_fileStream, Encoding.UTF8);

// Читаем первоначальное содержимое файла и выводим результат на консоль
var text = _fileStreamReader.ReadToEnd();
Self.Tell(new InitialRead(_filePath, text));
```

Несомненно, этот код рабочий, но логику инициализации следует расположить в методе `PreStart()`.

Самое время воспользоваться нашими знаниями о жизненном цикле актора!

Перенесите всю логику из конструктора `TailActor` в `PreStart()`. Также придется убрать `readonly` модификатор у полей `_observer`, `_fileStream`, и `_fileStreamReader`, поскольку они уже инициализируются не в конструкторе.

Начало файла `TailActor.cs` должно выглядеть подобным образом

```csharp
// TailActor.cs
private FileObserver _observer;
private Stream _fileStream;
private StreamReader _fileStreamReader;

public TailActor(IActorRef reporterActor, string filePath)
{
    _reporterActor = reporterActor;
    _filePath = filePath;
}

// we moved all the initialization logic from the constructor
// down below to PreStart!

/// <summary>
/// Initialization logic for actor that will tail changes to a file.
/// </summary>
protected override void PreStart()
{
    // start watching file for changes
    _observer = new FileObserver(Self, Path.GetFullPath(_filePath));
    _observer.Start();

    // open the file stream with shared read/write permissions (so file can be written to while open)
    _fileStream = new FileStream(Path.GetFullPath(_filePath), FileMode.Open, FileAccess.Read,
        FileShare.ReadWrite);
    _fileStreamReader = new StreamReader(_fileStream, Encoding.UTF8);

    // read the initial contents of the file and send it to console as first message
    var text = _fileStreamReader.ReadToEnd();
    Self.Tell(new InitialRead(_filePath, text));
}
```

Намного лучше! Ладно, что дальше?

### Самое время позаботится о корректном закрытии ресурсов  файловой системы `FileSystem`
`TailActor` создает файловые ресурсы и хранит их в полях `_fileStreamReader` и `FileObserver`. Воспользуемся методом `PostStop()`, чтобы гарантировать очистку этих ресурсов.

Добавьте этот код в `TailActor`:

```csharp
// TailActor.cs
/// <summary>
/// Очищает файловые ресурсы для <see cref="_fileStreamReader"/> и <see cref="FileObserver"/>.
/// </summary>
protected override void PostStop()
{
    _observer.Dispose();
    _observer = null;
    _fileStreamReader.Close();
    _fileStreamReader.Dispose();
    base.PostStop();
}
```

### Фаза 4: Собираем и запускаем!
Вот оно! После нажатия `F5` приложение будет работать точно так  же, как и раньше, но будет более лучше оптимизированным :)

### Когда все сделано
Сравните код, который у вас вышел с примером [Completed](Completed/) , обратите внимание на комментарии в примере.

## Отличная работа!
### УРРРЯЯ! ВЫ ПОБЕДИЛИ! Феноменально успешное завершение первого блока.

**Хочется большего? [Начать второй блок СЕЙЧАС](../../Unit-2 "Akka.NET Bootcamp Unit 2").**

## Есть вопросы?
**Не стесняйтесь задавать вопроосы** :).

Можете задавать любые вопросы, большие и маленькие, [в этом чате команд Petabridge и Akka.NET (английский)](https://gitter.im/petabridge/akka-bootcamp).

### Проблемы с кодом?
Если у вас возникил проблемы с запуском кода или чем-то другим, что необходимо починить в уроке, пожалуйста, [создайте issue](https://github.com/petabridge/akka-bootcamp/issues) и мы это пофиксим. Таким образом вы поможете всем кто будет проходить эту обучалку.
